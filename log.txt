Line 1: type_specifier	: INT
int
Line 1: type_specifier	: INT
int
Line 1: parameter_list  : type_specifier ID
int n
Line 3: variable : ID
n
Line 3: factor : variable
n
Line 3: unary_expression : factor
n
Line 3: term : unary_expression
n
Line 3: simple_expression : term
n
Line 3: factor : CONST_INT
0
Line 3: unary_expression : factor
0
Line 3: term : unary_expression
0
Line 3: simple_expression : term
0
Line 3: rel_expression : simple_expression RELOP simple_expression
n == 0
Line 3: logic_expression : rel_expression
n == 0
Line 3: expression : logic_expression
n == 0
Line 3: factor : CONST_INT
1
Line 3: unary_expression : factor
1
Line 3: term : unary_expression
1
Line 3: simple_expression : term
1
Line 3: rel_expression : simple_expression
1
Line 3: logic_expression : rel_expression
1
Line 3: expression : logic_expression
1
Line 3: simple_statement : RETURN expression SEMICOLON
return 1 ;
Line 4: simple_statement : IF LPAREN expression RPAREN simple_statement
if ( n == 0 ) return 1 ;
Line 4: statement: simple_statement
if ( n == 0 ) return 1 ;
Line 4: statements : statement
if ( n == 0 ) return 1 ;
Line 4: variable : ID
n
Line 4: factor : variable
n
Line 4: unary_expression : factor
n
Line 4: term : unary_expression
n
Line 4: variable : ID
n
Line 4: factor : variable
n
Line 4: unary_expression : factor
n
Line 4: term : unary_expression
n
Line 4: simple_expression : term
n
Line 4: factor : CONST_INT
1
Line 4: unary_expression : factor
1
Line 4: term : unary_expression
1
Line 4: simple_expression : simple_expression ADDOP term
n - 1
Line 4: rel_expression : simple_expression
n - 1
Line 4: logic_expression : rel_expression
n - 1
Line 4: arguments : logic_expression
n - 1
Line 4: argument_list : arguments
n - 1
Line 4: factor : ID LPAREN argument_list RPAREN
fact ( n - 1 )
Line 4: unary_expression : factor
fact ( n - 1 )
Line 4: term : term MULOP unary_expression
n * fact ( n - 1 )
Line 4: simple_expression : term
n * fact ( n - 1 )
Line 4: rel_expression : simple_expression
n * fact ( n - 1 )
Line 4: logic_expression : rel_expression
n * fact ( n - 1 )
Line 4: expression : logic_expression
n * fact ( n - 1 )
Line 4: simple_statement : RETURN expression SEMICOLON
return n * fact ( n - 1 ) ;
Line 4: statement: simple_statement
return n * fact ( n - 1 ) ;
Line 4: statements : statements statement
if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ;
Line 5: compound_statement : LCURL statements RCURL
{ if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
ScopeTable# 11
0 --> <n: VAR> 
ScopeTable# 1
2 --> <fact: FUNC_DEF> 
Line 5: func_definition : type_specifier ID LPAREN parameter_list RPAREN compound_statement
int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
Line 5: unit : func_definition
int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
Line 5: program : unit
int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
Line 6: type_specifier	: INT
int
Line 8: type_specifier	: INT
int
Line 8: declaration_list : ID
a
Line 8: var_declaration : type_specifier declaration_list SEMICOLON
int a ;
Line 8: simple_statement : var_declaration
int a ;
Line 8: statement: simple_statement
int a ;
Line 8: statements : statement
int a ;
Line 9: variable : ID
a
Line 9: factor : CONST_INT
5
Line 9: unary_expression : factor
5
Line 9: term : unary_expression
5
Line 9: simple_expression : term
5
Line 9: rel_expression : simple_expression
5
Line 9: logic_expression : rel_expression
5
Line 9: arguments : logic_expression
5
Line 9: argument_list : arguments
5
Line 9: factor : ID LPAREN argument_list RPAREN
fact ( 5 )
Line 9: unary_expression : factor
fact ( 5 )
Line 9: term : unary_expression
fact ( 5 )
Line 9: simple_expression : term
fact ( 5 )
Line 9: rel_expression : simple_expression
fact ( 5 )
Line 9: logic_expression : rel_expression
fact ( 5 )
Line 9: expression : variable ASSIGNOP logic_expression
a = fact ( 5 )
Line 9: expression_statement : expression SEMICOLON 
a = fact ( 5 ) ;
Line 9: simple_statement : expression_statement
a = fact ( 5 ) ;
Line 9: statement: simple_statement
a = fact ( 5 ) ;
Line 9: statements : statements statement
int a ; a = fact ( 5 ) ;
Line 10: compound_statement : LCURL statements RCURL
{ int a ; a = fact ( 5 ) ; }
ScopeTable# 12
7 --> <a: VAR> 
ScopeTable# 1
2 --> <fact: FUNC_DEF> 
3 --> <main: FUNC_DEF> 
Line 10: func_definition : type_specifier ID LPAREN RPAREN compound_statement
int main ( ) { int a ; a = fact ( 5 ) ; }
Line 10: unit : func_definition
int main ( ) { int a ; a = fact ( 5 ) ; }
Line 10: program : program unit
int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } int main ( ) { int a ; a = fact ( 5 ) ; }
Line 10: start : program
int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } int main ( ) { int a ; a = fact ( 5 ) ; }
ScopeTable# 1
2 --> <fact: FUNC_DEF> 
3 --> <main: FUNC_DEF> 
Total Line: 10
